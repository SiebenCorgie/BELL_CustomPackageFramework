%% LyX 2.2.1 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[12pt,ngerman]{article}
\usepackage[T1]{fontenc}
\usepackage[latin9]{luainputenc}
\usepackage[a4paper]{geometry}
\geometry{verbose,tmargin=2.5cm,bmargin=2cm,lmargin=2.5cm,rmargin=2.5cm}
\setlength{\parskip}{\medskipamount}
\setlength{\parindent}{0pt}
\usepackage{float}
\usepackage{graphicx}
\usepackage{setspace}

\usepackage{titletoc}

% \dottedcontents{<section>}[<left>]{<above-code>}
% {<label width>}{<leader width>}
\dottedcontents{section}[0em]{\bfseries}{2.9em}{1pc}
\dottedcontents{subsection}[0em]{}{3.3em}{1pc}

% center the toc heading
\renewcommand{\contentsname}{\centering Contents}


\onehalfspacing

\makeatletter
\@ifundefined{date}{}{\date{}}
\makeatother

\usepackage{babel}
\usepackage{listings}
\renewcommand{\lstlistingname}{Listing}

\begin{document}

\title{Besondere Lernleistung: }

\title{Custom Package Framework}

\maketitle
\vspace{50bp}

\begin{center}
An der
\par\end{center}

\begin{center}
Montessori Schule Huckepack e. V.
\par\end{center}

\vspace{30bp}

Vorgelegt von: 
\begin{center}
Tendsin Mende
\par\end{center}

\begin{center}
Pohlandstraße 5
\par\end{center}

\begin{center}
01309 Dresden
\par\end{center}

Abgabetermin: 
\begin{center}
27.02.2016
\par\end{center}

Betreuer:
\begin{center}
Herr Diplom. Lehrer Gerd Bobe
\par\end{center}

\begin{center}
Montessori Schule Huckepack e. V.
\par\end{center}

\thispagestyle{empty}

\pagebreak{}

\tableofcontents{}

\setcounter{page}{1}

\pagebreak{}

\section{Einführung}

\subsection{Die Situation}

,,Schön! Ich habe ein Linux, aber wie bearbeite ich ein Bild?{}``

An diesem Problem möchte ich mit meiner Arbeit ansetzen. Ich möchte
ein- und Umsteigern das Suchen von Programmen erleichtern. Ich sehe
drei Hauptprobleme für Neueinstieg.

\subsection{Grund 1}

Auch wenn es die Programme von Windows und MacOSx nicht gibt, so ist
die Auswahl an Programmen zu groß. Als Beispiel: Es gibt kein offizielles
Adobe: Photoshop für Linux\footnote{Vgl. https://helpx.adobe.com/photoshop/system-requirements.html, (14.08.2016,
13:57)}. Es gibt aber Gimp, Krita, MyPaint, und viele mehr. Welches davon
soll ich nehmen? Aus meiner Erfahrung kann ich sagen: ,,Krita für
malen und Texturbearbeitung und Gimp für Photos``. Aber diese Erfahrung
hat der Normalverbraucher nicht. Meine Lösung ist einfach: Ich gebe
dem Nutzer nur Gimp und Krita und eine Beschreibung mit meiner Erfahrung.

\subsection{Grund 2}

Das nächste Problem ist recht trivial. Wie installiere ich Software? 

Die meisten Umsteiger kommen von Windows. Sie erwarten, dass man ins
Internet geht, den richtigen ,,Installer`` herunterlädt und dann
installiert. Auf Linux kann man das Installieren aber eher mit einem
Appstore vergleichen. Man wählt sein Paket (Programm) und lädt es
sich von einem Spiegel-Server herunter. Das Paket weiß selbst welche
anderen Programme es benötigt und installiert diese nach. Der Vorteil
dieser Methode ist, dass sich viele Programme einzelne Unterprogramme
teilen können. Außerdem lässt sich das System so einfach mit dem Server
abgleichen. Das Aktualisieren der Programme ist einfacher. 

\section{Vorüberlegungen}

\subsection{Ziel}

Meine ersten Überlegungen galten zwangsläufig meinem Ziel. Wie sollte
mein Programm aussehen um einen möglichst einfachen einstieg in Linux
zu gewährleisten?

Ich kam zu dem naheliegenden Schluss, dass es das beste sei eine einfache
Oberfläche zu konstruieren. Es entstanden die ersten Ideen. 

Meine fertige Idee bestand aus einem Rahmen, welcher in drei Teile
gegliedert war. Der Programmauswahl, ein Dokumentationsbrowser und
einem Informationssystem. Die Programmauswahl sollte Icons für verschiedene
Programm-arten bekommen (z. B. ,,Video und Foto``, ,,Musik``,
,,Spiele``). Durch das Anklicken der Icons sollte man in eine Feinauswahlen
kommen, bis man nach maximal drei Verzeichnissen eine Programmauswahl
präsentiert bekommt.

Der Dokumentationsbrowser soll die Aufgabe übernehmen, Dokumentation
zugänglich zu machen. Dabei denke ich primär an Schul- oder firmeninterne
Dokumentation. 

Der Informationsbrowser wiederum soll über neue Entwicklungen informieren.
Es bietet sich an Blog-Webseiten oder Nachrichten an dieser Stelle
zu laden.

Ein nicht zu unterschätzender Teil ist die Administration eines solchen
Programms. Ich weiß aus Erfahrung meines ersten größeren Programms\footnote{siehe: https://github.com/SiebenCorgie/Beta-Launcher , 18.08.2016,
18:30}, dass man ein gutes Konfigurations-System braucht. Bei CPF (kurz
für: Custom Packaging Framework) würde außerdem noch ein weiteres
Problem hinzu kommen. Da es sich um die Installation von Programmen
handelt, muss die Sicherheit des System gewährleistet sein. Das heißt
es muss genau geregelt werden wie man installiert und welche Programme
welchen zugriff auf Dateien haben.

\subsection{Konfiguration}

\subsubsection{Programm eigene Konfiguration}

Die Programm eigene Konfiguration umschließt die Art, wie CPF reagieren
soll. Dazu sollte gehören:
\begin{itemize}
\item Umgang mit der Datenbank
\begin{itemize}
\item Speicherung von Daten
\item Abrufen von Daten
\end{itemize}
\item Umgang mit dem Internet
\begin{itemize}
\item Laden der Webseiten in Dokumentation und Info-System
\item Herunterladen von Programmen
\item Abgleichen der Datenbank mit online Repositorium
\end{itemize}
\item Verhalten während der Installation
\begin{itemize}
\item Automatisierungsgrad während der Installation
\item Passwort-abfrage (welcher Benutzer fragt?)
\end{itemize}
\item Massenaufträge
\begin{itemize}
\item Grafische Rückmeldung
\end{itemize}
\end{itemize}
Die verschiedenen Optionen werden in verschiedenen Registerkarten
eines Konfigurationsfensters geändert. Das ist erfahrungsgemäß die
übersichtlichste Art.

\subsubsection{Datenbank}

Die Datenbank soll aus einfachen Datensätzen mit verschiedenen Daten
beruhen. zu diesen Daten soll gehören:
\begin{itemize}
\item Name des Programms
\item Entwicklerbeschreibung (kurzbeschreibung)
\item Eigene Beschreibung (lange Beschreibung)
\item Programm Typ (Grafik, Video, Spiel, etc.) (Überkategorie)
\item Unterkategory
\item Programm Website
\item Pfad zu Screenshot
\end{itemize}

\subsubsection{Datenbank Management}

Die Datenbank soll außerdem erweiterbar sein. Dazu muss auch ein eigenes
Tool geschrieben werden. Die Erweiterung wird aus einer Eingabemaske
bestehen sowie der Option die lokale Datenbank in das Repositorium
hoch zu laden.

\subsection{Installation}

\subsubsection{Visualisierung}

Das Installieren von Software soll mit minimalem visuellen eindrücken
auskommen. Dabei möchte ich nur den Fortschritt, und den Namen der
Aktion anzeigen. Die Werte sollen im unteren Teil des Programms angezeigt
werden. 

\subsubsection{Installationsablauf}

Die Installation soll wie folgt ablaufen:
\begin{enumerate}
\item Programm Auswahl
\item Installations-Start
\item Passwort-abfrage (Benutzer wird aus Konfigurationsdateien gelesen)
\item Bestätigung
\item Installation
\item Erfolgs/Misserfolgs-Nachricht
\end{enumerate}
Bei einem Misserfolg soll nach Möglichkeit der Fehler angezeigt werden.
Insofern benötigt soll man auch den Lockbuch-Eintrag sehen können.

\subsubsection{Massenaufträge}

Das Programm soll Massenaufträge abarbeiten können. Dies soll vor
allem Administratoren die Arbeit ersparen. Bei einem Massenauftrag
werden viele Programme mit einem mal installiert. 

\subsubsection{Programmauswahl}

Die Programme sollen wie in 2.1 beschrieben durch fein Filtern der
Optionen ausgewählt werden. Ich werden versuchen die Beschreibungen
möglichst neutral zuhalten. Damit soll die Entscheidung des Nutzers
möglichst neutral bleiben, um zum gewünschten Programm zu gelangen.

\subsection{Web-Integration}

Die Webintegration soll über PyWebKit\footnote{siehe: https://webkit.org/ , 14.08.2016, 20:18}
erfolgen. Das ist eine von Apple entwickelte Umgebung, um relativ
einfach Browserfähigkeiten in Gtk-Programme einzubauen. Ich werde
es verwenden um einfache Webseiten anzuzeigen. Die Lizenzierung von
WebKit\footnote{https://webkit.org/licensing-webkit/ , 14.08.2016 , 20:21}
ermöglicht es mir das Programm kommerziell oder nicht-kommerziell
zu entwickeln und zu veröffentlichen.

\subsection{Programmiersprache}

Als Programmiersprache nehme ich Python.Es gibt verschiedene Gründe
dafür. 

Der Erste ist, dass ich schon seit Sommer 2015 Programme mit Python
schreibe. Ich kann es relativ ,,flüssig`` schreiben. Diese Vorkenntnis
ist nötig um in der gegebenen Zeit ein so komplexes Programm zuschreiben. 

Der zweite Grund ist, dass Python eine interpretiere\footnote{Siehe: https://de.wikipedia.org/wiki/Interpreter}
Sprache ist. Der Vorteil ist, dass ein Python-Programm bei einem Programmfehler
nicht abstürzt. Es führt in meinem Fall den Befehl nicht aus und kehrt
in die Warte-Position zurück\footnote{Die Charackteristik eines Gtk+ Interfaces wird Später noch geklährt.}.
Dadurch ist das potenzielle Installieren fehlerhafter Software, oder
frustrierende abstürze des Programms geringer. Ein Nachteil ist, dass
man Programmfehler erst bei der Ausführung findet. Das Testen wird
dadurch aufwendiger.

Der Dritte Grund ist Pythons Anbindung an das GTK+ Projekt. Wie ich
im nächsten abschnitt beschreiben werde nutze ich das GTK+ um meine
grafische Umsetzung zu realisieren. Bei einem so grundlegenden Element
ist es wichtig, dass die Anbindung an die Programmiersprache gut ist.
Dies ist bei Python glücklicherweise gegeben.

\subsection{Interface-Toolkit}

Das Interface-Toolkit\footnote{kurze Erklährung: https://de.wikipedia.org/wiki/Toolkit}
ist auf Linux zu Verständigung zwischen dem Display-Server (z.B. X11
oder Wayland) und dem Benutzer zuständig. Es stellt verschiedene Elemente
bereit, die zusammen das fertige Programm-Interface ergeben (siehe
Abb.1). 

\begin{figure}[H]
\caption{\textit{Schematische Darstellung der Beziehungen}}
\scalebox{0.5}{\includegraphics[clip]{Bilder/Schema_der_Schichten_der_grafischen_Benutzeroberflaeche}}

Quelle: https://en.wikipedia.org/wiki/File:Schema\_of\_the\_layers\_of\_the\_graphical\_user\_interface.svg\#/media/File:Schema\_der\_Schichten\_der\_grafischen\_Benutzeroberfl\%C3\%A4che.svg
, Shmuel Csaba Otto Traian, 29.10.2013
\end{figure}

.Ich habe mich für GTK+\footnote{Englisch: http://www.gtk.org/ ,18.08.2016, 21:25}
entscheiden. Der wichtigste Grund wurde schon in ,,2.5 Programmiersprache``
angeführt. GTK+ hat eine exzellente Pythonanbindung (ab jetzt API
, kurz für Application-Programming-Interface). Allerdings macht sich
GTK+ durch weitere Vorteile prädestiniert für den Einsatz in meinem
Programm.

Ein weiterer großer Vorteil ist die Lizenzierung. Gtk+ ist unter LGPL\footnote{Englisch: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html ,
18.08.2016 , 21:32} Lizenziert\footnote{Englisch: http://www.gtk.org/ , 18.08.2016, 21:32}.
Diese erlaubt es mir GTK ohne Restriktionen einzusetzen. Die LGPL
Lizenz ist eine der am weitesten verbreiteten Lizenzen in der OpenSource-Welt.
Der Erfolg durch die Lizenz und die Qualität lässt sich auf Linux
leicht erkennen. Es gibt sehr viele Programme die mit dem GTK erstellt
wurden. Des weiteren gibt es sogar eine ganze Desktop-Umgebung die
auf GTK basiert. Genannt ,,Gnome``\footnote{Englische Referenz: https://www.gnome.org/},
welche ich selbst benutze. Das GTK Projekt ist eines der ältesten\footnote{https://www.gimp.org/about/ancient\_history.html , 08.18.2016 , 21:47}
und erfolgreichsten Linux-Projekte im grafischen Segment. Mit dem
Erfolg kommt eine weite Verbreitung im Linux-Anwenderbereich. Der
kommt mir insofern zugute, als das es auf fast allen Distributionen
die benötigten Pakete für mein Programm gibt.

Der letzte Grund für das GTK+ ist meine Erfahrung. Wie in 2.5 erwähnt
habe ich schon einige Erfahrung auf dem Gebiet von Python. Dazu gehört
es auch, dass ich ab Ostern 2016 ein Programm\footnote{siehe: https://github.com/SiebenCorgie/Beta-Launcher}
zum Organisieren und Installieren der UnrealEngine 4 auf Linux geschrieben
habe. Dieses war auch mit GTK erstellt worden. Ich habe während des
Programmierens viel Erfahrung gesammelt. Damals habe ich mehrere Toolkits
miteinander verglichen (z.B. Qt und wxWidgets). Am Ende habe ich mich
für das Gtk entscheiden. Das Ergebnis ist ein gefestigtes Anfängerwissen
über ein Toolkit welches ich mir bewusst gesucht habe. 

\subsection{Unterstützung}

Ich plane die Unterstützung des .deb Formates und des .tar.xz Formates.
Das heist es gibt Unterstützung von Debian und dessen Distributionen
sowie Arch-Linux und dessen Distributionen. 

Dabei ist zu beachten das Ubuntu eine andere ,,naming-convention``
hat als Debian, allerdings trotzdem auf dem .deb Format beruht. Deshalb
werde ich in meiner Programmdatenbank zwei verschiedene Speicherplätze
für Debian und Ubuntu basierte Systeme einrichten.

In der Linux-Welt gibt es noch ein anderes, sehr weit verbreitetes
Format: .rpm\footnote{Kurze Erklährung: https://en.wikipedia.org/wiki/RPM\_Package\_Manager
, 01.09.2016, 16:49}. Mit diesem Format habe ich allerdings keine Erfahrung. Deshalb werde
ich es nicht benutzen. Es wäre möglich sich mit dem Format zu beschäftigen,
allerdings hängt es sehr stark von der gewählten Distribution ab wie
man das Paket erstellt. Deshalb habe ich mich entschieden das Format
vollkommen aus zu lassen. 

\subsection{Arbeitsweise}

\subsubsection{Schreiben}

Ich werde das die Dokumentation mit Lyx\footnote{http://www.lyx.org/ , 01.09.2016, 17:37}
schreiben. Das ist ein grafisches Programm zum LATEX-Framework\footnote{http://www.latex-project.org/ , 01.09.2016, 17:35}.
Der Grund dafür ist vorallem die gute Linux-Unterstützung sowie das
exzelente Schriftbild welches durch das LATEX Programm erstellt wird.
Desweiteren ist LATEX als Dokumentensprache in wissenschaftlichen
Arbeiten weit verbreitet. Die Arbeit damit stellt also auch eine gewissen
Vorbereitung für mich dar.

\subsubsection{Git-Hub}

Das Programm sowie die Dokumentation kommen in eine Programm-Ordnerstruktur.
Diese soll mit einem Git-Hub Repositorium abgeglichen werden. Dadurch
errreiche ich maximale Transparenz was das Programm und dessen Fortschritt
angeht. Außerdem ist das bearbeiten von Programmen über Git-Hub eine
sehr weit verbreitete Praxis in der Linux-Welt. 

Git-Hub ist eine Online-Umgebung bei der man Programme hochladen kann.
Es hebt sich von normalen Web-Hosts in sofern ab, als das man als
Administrator des Repositoriums änderungen anderer annehmen und prüfen
kann. Außerdem gibt es einen sehr ausgeklügelten Mechanismus um lokale
Versionen eines Programms mit der Onlineversion zu synchronisieren\footnote{Mehr Informationen über Git-Hub: https://de.wikipedia.org/wiki/GitHub
, 01.09.2016, 17:46}.

\section{Dokumentation der Arbeit}

\subsection{Voranmerkung}

Die Dokumentation ist in der Reihnfolge in der Reihnfolge in der ich
das Programm geschrieben habe. Es ist ausserdem gut eine Version des
Programm-Listings griffbereit zu haben. Ich werde hin und wieder indirekt
bezug auf einzelne Stellen nehmen. Insofer erforderlich baue ich auch
Listing-Stellen in den Text ein. 

\subsection{Erstellung des Programms}

Das Programm selbst lasse ich zuerst durch den Python-GTK wizard von
Anjuta erstellen. Das ist schnell durch den Dialog ,,Create NEw Project``
mit den Einstellung für ein Python-GTK projekt getan. Dieser Wizard
erstellt in einem Ordner die Typische Ordnerstruktur eines Linux-Programms.
Nach dem Hinzufügen meiner eigenen Ordner für Dokumentation und Refernzen
haben ich die Ordnerstruktur aus Abb. 2.
\begin{center}
\begin{figure}[h]

\centering{}\caption{\textit{Grund Ordnerstruktur}}
\includegraphics[scale=0.5]{Bilder/DefaultDirectoryStructure}
\end{figure}
\par\end{center}

Dieser Ordnerstruktur soll mit einem Git-Hub Repositorium abgeglichen
werden. Dazu kreiere ich zuerst ein leeres Repositorium (ab jetzt
Repo.) auf Git-Hub mit meinem Benutzer. Danach klone ich es auf meinen
Computer. In den zurzeit leeren Ordner kopiere ich das gerade erstellte
Projekt. Danach synchronisiere ich mithilfe der folgenden Kommandos:
\begin{lstlisting}
# Dateien und Ordner zu Lokalen Repo hinzufügen
git add *
#Dateien lokal Synchronisieren und Nachricht hinterlassen
git commit -a
#Lokale neue Version online synchronisieren
git push
\end{lstlisting}

Jetzt ist die Grundstruktur online Hinterlegt. Ich kann mir jederzeit
eine Version der Struktur herunterladen, bearbeiten und die neue Version
hochladen. Der erste ,,commit`` hat die Nachricht: ,,Initial commit``.

\subsection{Erstellung der Grafischen Oberfläche: Hauptfenster}

In Anjuta gibt es den ,,Glade`` den UI-Editor für mein GTK-Interface.
mit ihm kann ich mithilfe verschiedener vorgegebener UI-Elementen
mein Hauptfenster Erstellen. Die einzelnen Schritte beinhalten immer
das einfügen des Widgets, die Namensgebung sowie die einstellung gewünschter
Parameter. 

Ich entscheide mich für eine traditionelle ,,Taskbar`` am oberen
Fensterrand, sowie einem Vertikalen ,,Notebook``. In dem Notbook
werden auf der ersten Position später die verscheidenen Programm-Kategorien
erscheinen. Auf der Zweiten und dritten Position ist der ,,Dokokumentation-Browser``
under der ,,Informations-Browser``. Das fertige Ergebnis sieht wie
in Abb. 3 aus.
\begin{figure}[h]
\caption{Haupt-Fenster}

\centering{}\scalebox{0.250}{ \includegraphics{Bilder/MainWindow_Show}}
\end{figure}


\subsection{Browserfenster}

Die Browserfenster werden beim Programmstart eingebunden. Dazu erstelle
ich in dem Fenster von ,,Documentation`` bzw. ,,Info`` ein WebKit-Browser.
Dieser Läd die ,,Home`` Url.

Wenn die Interaktion mit dem Internet in den Einstellungen deaktiviert
ist wird WebKit garnicht eingebunden und stattdessen ein Fehler-Icon
angezeigt.

\subsection{Konfiguration}

\subsubsection{Konfigurationsdatei}

Zuerst erstelle ich mir eine eigene Konfigurationsdatei. In ihre werden
alle Konfigurationen gespeichert die das Programm über mehrere Läufe
hinweg behalten soll. Die Datei ist in Überabschnitte geteilt. Deren
Namen sind in eckigen Klammern eingefasst. Die Namen der Werte folgen.
Nach einem Gleichheitszeichen folgt der Wert. Eine Überkategorie mit
Wertenamen und Wert sähe also wie folgt aus: 
\begin{lstlisting}
[Ueberkategorie]
Name = Wert
\end{lstlisting}

Diese Syntax kann von einem Modul in Python gelesen werten. Dadurch
ist es für mich einfachere die Werte auszulesen und zu ändern.

\subsubsection{Lesen und Schreiben}

\paragraph{Allgemeines}

Wie schon angekündigt nehme ich zum lesen und schreiben der Werte
ein Modul. Dieses heißt ,,Configparser``\footnote{Dokumentation: https://docs.python.org/3.5/library/configparser.html
, 01.09.2016, 18:35}. Mit der in \cite{key-7} beschriebenen API kann ich nun Dateien
ein und auslesen, sowie Einträge ändern. Der Pfad zur Konfiguationsdatei
ist im Programmierstatus noch lokal direkt im verzeichnis. Im installierte
zustand wird die konfigurationsdatei immer im Home-Verzeichnis des
Nutzers liegen.

Für die Konfiguration legen ich eine neue Pythondatei mit dem Namen
CPFConfig an. Diese importiere ich in das Hauptprogramm under dem
Pseudonym ,,conf``. In der neuen Datei erstelle ich die Funktionen:
\begin{enumerate}
\item set\_entry (auslesen eines Wertes)
\item get\_entry (einlesen eines Wertes)
\item load\_config (laden der Werte des Konfigurationsmenus)
\item save\_config (schreiben der Werte des Konfigurationsmenus)
\end{enumerate}
Außerdem kommen vor die funktionen noch die Befehle um die Konfigurationsdatei
ein zulesen. Dabei wird die datei in die variable ,,config`` als
ConfigParser Objekt gespeichert. damit kann ich auf ,,config`` alle
Funktionen des ConfigParser Objekts anwenden. Danach lese ich mit
dem Befehl ,,read`` die Konfigurationsdatei ein.

\paragraph{Die Funktion set\_entry}

Die Funktion nimmt Werte für die Variablen ,,section``, ,,entry``
und ,,newentry`` entgegen. Danach wendet sie ,,set`` auf das ,,config``
objekt an. ,,Set`` bekommt als Argumente die Kategorie des neuen
Wertes (,,section``) den Namen (,,entry``) und den neuen Wert
(,,newentry``). 

Danach schreibt sie die neuen Werte in die Konfigurationsdatei. 

\paragraph{Die Funktion get\_entry}

Die Funktion nimmt zwei Werte entgegen: ,,section`` und ,,entry``.
Ähnllich wie bei set\_entry werden die werte auf das ,,conf`` Objekt
angewendet um mit den argumenten ,,section`` udn ,,entry`` den
Korospondierenden Wert wieder zugeben. Dabei steht diese anweisung
in der ,,return`` Anweisung. Dies sorgt dafür, dass der Aufrufer
der Funktion den Wert in der Konfigurationsdatei zurück bekommt. Dieser
Wert wird meist in einer Variable gespeichert.

\paragraph{Die Funktion load\_config}

Die Funktion ist dazu da den Inhalt des Konfigurations-Dialogs fest
zu legen. Sie nimmt als Argument nur den Konztruktor des GTK-Fensters
(builder). Dadurch kann man in der Funktion auch das grafische Interface
aus der Klasse ,,GUI`` bearbeiten. Dabei wird für jedes Widget der
Wert aus der Konfigurationsdatei geladen. Es handelt sich in fast
allen fällen um einen Text der geladen wird. Das ist relativ einfach:

Zuerst legt man eine Variable mit dem Objekt an. Anschließend wird
der alte Wert des Textes mit dem neuen überschrieben. Der neue Wert
wird über die get\_entry Funktion aus der Konfigurationsdatei gelesen.

Es gibt allerdings auch zwei sonderfälle. Einmal Verzeichnis-Auswahlen
und eine ,,Ja/Nein``-Auswahl durch eine ,,Tick-Box``.

Beid der Verzeichnis-Auswahl liest das Programm den gespeicherten
Pfad aus der Konfiguationsdatei. Danach wird die Datei über ,,set\_filename``
ausgewählt.

Bei den Tickboxen hat man nur die auswahl zwischen gesetztem Hacken
oder leerem Feld. Deshalb liest das Programm die Konfigurationsdatei
ein. Wenn an der stelle ,,True`` gespeichert ist wird der Hacken
aktiviert. Ansonsten wird er deaktiviert.

\paragraph{Die Funktion save\_config}

Diese Funktion Ist die Umkehrung der ,,load\_config`` Funktion.

Sie liest über den ,,Builder`` alle Texte ein und speichert sie
an ihrem Platz in der Konfigurationsdatei. 

Texte werden dabei eingelesen, indem das Objekt also Variable gespeichert
wird. Danach wird dessen Textobjekt ausgelesen und dessen Wert gespeichert.

Bei der Auwahl eines Verzeichnises gibt es ein eigenes Widget. Bei
diesem erfährt man den Pfad zum gewählten Verzeichnis durch die Methode
,,get\_filename``. Diese gibt den Pfad als String aus.

Wenn keine Veränderung vorgenommen wurde ist allerdings der Wert der
von ,,get\_filename`` ausgeben wird ,,None``. Um zu verhindern,
dass in der Konfigurationsdatei ,,None`` als Pfad gespeichert wird,
liest das Programm den Pfad ein. Wenn der Pfad ,,None`` ist wird
die Konfigurationsdatei nicht geändert. Ansonsten wird der neue Wert
von ,,get\_filename`` eingespeichert.

Bei der Tick-Box hat man nur die Möglichkeit einen Hacken zusetzen,
oder ihn nicht zusetzen. Dabei ist die schwierigkeit nur, dass wenn
der Hacken gesetzt wird der String ,,True`` eingespeicher wird.
Wenn er nicht gesetzt ist, wird ,,False`` eingespeichert.

\subsubsection{Konfigurationsmenu}

Das grafische Menu habe ich nach den Kategorien der Konfigurationsdatei
gegliedert:
\begin{itemize}
\item Internet
\item Datenbank
\item Installation
\item MassInstall
\end{itemize}
In den Kategorien gibt es eine Zwei-Spalten-Liste. Jeweils mit links
der Beschreibung der Einstellung und rechts dem Wert. Also Text oder
Auswahl-Dialog.

Auf der untersten Leiste liegen die Knöpfe zum Speichern und Verwerfen.

\begin{figure}[h]

\centering{}\caption{Einstellungsdialog}
\scalebox{0.25}{\includegraphics{Bilder/PrefWin}}
\end{figure}


\subsection{Datenbank}

\subsubsection{Technisches über die Datenbank}

Die Datenbank schreibe ich über das Modul ,,sqlite3``. Das ist eine
einfachere Version der beliebten SQL-Datebank mit Pythonitegration\footnote{https://docs.python.org/2/library/sqlite3.html, 06.09.2016, 19:06}.
Mit diesem Modul kreiert oder läd man eine Datenbank-Datei. Diese
kann man anschließend über der ,,Curser`` also eine Art Pfeil manipulieren.
Nach der Manipulation werden die änderungen ähnlich wie bei Git-Hub
gesammelt und die Datei mit den Änderungen aktualisiert. 

\subsubsection{Datenbankiteraktion}

Die Interaktion besteht aus mehreren Aktionen:
\begin{enumerate}
\item Erstellen einer Datenbank und einer Liste
\item Erstellen neuer Einträge
\item Lesen der Einträge nach verschiedenen Aspekten
\end{enumerate}
Die Datenbank enthält nur eine Liste: ,,CPFDB``. In dieser Liste
steht:
\begin{enumerate}
\item Name
\item Kurzbeschreibung
\item Lange Beschreibung
\item Name in den Ubuntu Repositorien
\item Name in den Debian Repositorien
\item Name in den Arch Repositorien
\item Pfad zu einem Bildschirmfoto des Programms
\item Pfad zu einem Symbol
\item Überkategorie
\item Unterkategorie
\item Webseiten URL des Entwicklers
\end{enumerate}

\subsubsection{Erstellen einer neuen Datenbank}

Die Datenbank im Dateiensystem umfasst nur eine Datei und zwei Ordner.
Die Datei ist die Datenbank und die Ordner beinhalten Symbole und
Screenshots der Programme.

Beim Erstellen werden die Ordner sowie die Datei erstellt. Dabei kann
bei bedarf die neue Datenbank direkt in die Konfigurationsdatei eingetragen
werden und damit aktiv werden. Der angebene Name in dem Erstellungs-Dialog
enstpricht dem Name der erstellten Datenbank.

Es ist zu beachten, dass Namen auf Linux nicht die Art der Datei beinhalten
müssen. Der Name: ,,Datenabnk.sh`` ist genauso zulässig wie ,,Datenbank.txt``
oder einfach nur ,,Datenbank``. 

\subsubsection{Erstellen neuer Einträge}

Das Erstellen neuer Einträge ist denkbar einfach. Man bekommt den
Dialog präsentiert. In dem Dialog kann man für jeden Eintrag eines
Datensatzes in der Datenbank einen Wert angeben. Vom Name, bis zur
URL der Entwickler-Homepage.

Eine kleine Außnahme machen hier die Auswahlen des Screenshots und
des Symbols. Bei der aktivierung kann man hier eine Datei auswählen.

Eine weitere Besonderheit ist das Klappmenü der Unterkategorie. Dieses
wird über die Funktion:
\begin{lstlisting}
update_sub_category
\end{lstlisting}

in dem Modul ,,CPFDatabase.py`` anhand des ausgewählten Eintrags
in dem Klappmenü der Hauptkategorie aktualieisert. Dabei wird der
aktive Eintrag gelesen. Danach wird mithilfe des Eintrages in der
Konfigurationsdatei nach allen möglichen Unterkategorien gesucht.
Diese List an Unterkategorien wird dann in dem Menü dargestellt. Es
ist zubeachten, dass das Menü vor dieser Prozedur geleert wird, um
Mehrfacheinträge bzw. falsche Einträge auszuschließen

Nachdem alle Einträge in dem Dialog einen Wert haben, kann man diesen
Datensatz der Datenbank hinzufügen. Die Funktion hierfür heißt: 
\begin{lstlisting}
db_add_entry
\end{lstlisting}
 in dem Modul ,,CPFDatabase.py``. Sie ließt alle Werte im Dialog
aus, speichert sie in Variablen und fügt diese über die SQL-Funktion
,,INSERT`` in die Datenbank ein. Die ID in der Datenbank wird automatisch
eingefügt.

Auch hier gibt es wieder zwei Besonderheiten. Die erste ist, dass
die Funktion versucht den Screenshot und das Symbol in ihren jeweiligen
Ordner zu verschieben. Wenn dies schief läuft wird ein Fehler-Dialog
angezeigt. 

Wenn versucht wird einen Eintrag hinzu zu fügen, allerdings ein Wert
nicht Spezifiziert ist, wird auch ein Fehler-Dialog angeziegt.

\subsubsection{Lesen der Einträge}

Beim Lesen von Einträgen habe ich mich dafür entschieden mehrere Funktionen
zu schreiben. Die erste ist:

\begin{lstlisting}
db_read
\end{lstlisting}

die Zweite ist:

\begin{lstlisting}
read_attributes
\end{lstlisting}

Die Funktion ,,db\_read`` gibt alle Namen aller Programme wieder
die eine spezifizierte Unterkategorie besitzen. Diese Funktion wird
nur in der Anzeige der Unterkategorien und ihrer Programme benötigt.
Dazu später mehr in der App-Anzeige. 

Die Funktion ,,read\_attributes`` hingegen ließt einen Gesamten
Datensatz anhand seines Names aus. Diese wird für alle übrigen Operationen
genutzt. Der zurück gegebene Wert ist eine Liste. Der Index andem
sich eine Information befindet ist dabei gleich der Reihnfolge der
Speicherplätze bei der Datenbankerstellung.
\begin{enumerate}
\item [0.]\setcounter{enumi}{0}ID
\item Name
\item Kurze Beschreibung
\item Lange Beschreibung
\item Screenshot Ort
\item Ubuntu-Name
\item Debian-Name
\item Arch-Name
\item Symbol Ort
\item Haupt-Kategorie
\item Unter-Kategorie
\item Entwickler-URL
\end{enumerate}
Achtung: Bei der Funktion ,,db\_add\_entry`` werden die Daten in
einer Anderen Reihnfolge angesteuert. Die Reihnfolge innerhalb der
Datenbank bleibt aber wie oben beschrieben.

\subsection{App-Anzeige}

\subsection{Installation}

\newpage{}

\listoffigures


\section{Anmerkung zum Literaturverzeichnis}

Das Literaturverzeichnis kennzeichnet Quellen mit englischen Inhalt
mit ,,EN``.
\begin{thebibliography}{1}
\bibitem{key-1}EN: WebKit Hauptseite: https://webkit.org/

\bibitem{key-2}EN: WebKit Lizens: https: https://webkit.org/licensing-webkit/
, gesamtes Dokument

\bibitem{key-2}EN: Gtk Hauptseite: http://www.gtk.org/

\bibitem{key-3}EN. LGPL Lizenz Webseite: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html

\bibitem{key-4}EN: Kurzfassung des GTK: https://www.gimp.org/about/ancient\_history.html

\bibitem{key-5}EN: Beta-Launcher, Mein erstes GTK-Projekt: https://github.com/SiebenCorgie/Beta-Launcher

\bibitem{key-6}EN: Unreal-Engine-4 Hauptseite: https://www.unrealengine.com/what-is-unreal-engine-4 

\bibitem{key-7}EN: Configparser Dokumentation: https://docs.python.org/3.5/library/configparser.html
\end{thebibliography}

\end{document}
